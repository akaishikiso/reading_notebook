# 初めての Go

## 基本型と宣言

### 論理型

- bool のゼロ値は false

### 整数型

- 特定の大きさと特定の符号の整数バイナリのファイルあるいはネットワークプロトコルを使用しているのであれば、対応する整数型を使う
- 全ての整数型について機能しているライブラリ関数を書く場合は、引数と戻り値が int64 のものと unit64 のものの二つの関数を書かなくてはいけない。
- その他の場合は int を用いる

```
Go 1.17までジェネリクス（や関数のオーバーロード）がなかったため、全ての整数型について機能するライブラリ関数を書くときに、int64及びuint64の関数を書くのがイディオム的に正しいとされてきたが、Go1.18からジェネリクスが導入され、複数の方に対応した関数を書くことができるようになった
→符号の有無やサイズについて明示する必要がない場合はint型を用いるのが良い。理由なく他の型を用いるのは「早すぎる最適化」
```

- 0 による割り算を行うとパニックが起こる

### 変数の宣言

- 変数をゼロ値に初期化する場合は`var x int`→ ゼロ値が意図されていることが明確になる
- 型が指定されていないリテラルを変数に代入するとき、そのリテラルのデフォルトの型が希望する変数の型と異なる場合、型を指定して長い形式の`var`を用いる<br/>🤔 `x := byte(20)`→✅ `var x byte = 20`
- どの変数が新しいものであるかを明示するために、var を使って新しい変数を明示的に宣言しておいてから、「＝」を使って変数に値を代入するようにする
- `var`や`:=`は複数の変数の宣言を一行で行えるが、このスタイルを使うのは複数の値を返す関数（あるいは「カンマ ok イディオム」）からの戻り値を代入する時にだけにする

### 未使用変数

- Go には「宣言されたローカル変数は全て使われなくてはならない」というルールがある。一度も使用されてない変数があるとコンパイルエラーになる

## 合成型

### Go 配列

- Go では配列が直接使われることは多くはない
- 配列の各要素は指定された型でなくてはならない
- 最後の要素を超えるインデックスを指定したり、値が範囲外になるとコンパイルエラーになる

→ 結構制限が厳しい<br/>
→「スライス」の「後方支援」のため。

### スライス

- スライス＝「可変長の配列」。宣言時に大きさを指定しない
- スライスは比較可能でない。同じスライスかどうか判定するのに`==`や`!=`を用いるとコンパイルエラー。スライスと比較できるのは`nil`だけ。
- `...`を用いることで、スライスの個々の値を展開できる。<br/>

```
y := []int{10,20,30} //スライス。大きさを指定しない
x := append(x, y...)
```

### マップ

[map について](map.)

マップとセット
多くの言語では標準ライブラリにセット（set:集合）が含まれる

セットは要素の値に重複なく要素間に順序があることは仮定されていないデータ型

ある要素があるセットに含まれるかのチェックは、要素数に関わらず高速に行うことができる。（これに対して、スライスにある要素が含まれるかのチェックは、サイズが大きくなるにつれて時間がかかるようになる。）

Go でのセットの仕方

```
// 以下のスライスについてマッピングする

companies := []struct {
		Id        int
		UpdaterId int
	}{
		{Id: 1, UpdaterId: 1},
		{Id: 2, UpdaterId: 2},
		{Id: 3, UpdaterId: 1},
		{Id: 4, UpdaterId: 3},
		{Id: 5, UpdaterId: 2},
		{Id: 6, UpdaterId: 4},
		{Id: 7, UpdaterId: 1},
		{Id: 8, UpdaterId: 3},
		{Id: 9, UpdaterId: 2},
		{Id: 10, UpdaterId: 4},
	}
```

1.  マップのキーにセットに含めたい要素を割り当て、値として bool を指定する

    ```
    idSet := map[string]bool{}

    for _, company := range companies {
    	id := company.UpdaterID
    	idSet[id] = true
    }

    fmt.Println(len(companies)) // 10
    fmt.Println(len(idSet)) // 4
    ```

2.  struct{}を使う

    - 真偽値は１バイトを消費するが、空の構造体は領域を全く消費しないと言う点で優れている
    - 一方、struct の方がわかりにくい代入の意味が明確でなくなり、カンマ ok イディオムを使って値がセットにあるかどうかチェックする必要がある

    ```
    idSet := map[int]struct{}{}

    for _, company := range companies {
    	intSet[company] = struct{}{}
    }

    if _, ok := idSet[3]; ok {
    	fmt.Println(updaterIdが3のものは存在する) // 4
    }
    ```

## ブロック、シャドーイング、制御構造

### シャドーイング

- シャドーイング変数：if 文の外側で宣言された変数名と同じ変数名を持つ、一番内側の変数（など）のこと。シャドーイング変数があると、元の変数にアクセスできなくなる。簡単に置き換えられてしまう。
- パッケージ名などもシャドーイング変数となる。ユニバースブロックにある識別子を再定義しないように気を付ける

### continue

- Go では if の本体は短くすることが求められる

```
🤔 NOT GOOD
for i := 1; i <=100; i++ {
		if i%3 == 0{
			if i%5 == 0{
				fmt.Print("i divides both 3 and 5")
			}else {
				fmt.Print("i divides only 3")
			}
		}else if i%5 == 0{
			fmt.Print("i divides only 5")
		} else {
			fmt.Print("i does not divide either 3 or 5")
		}
	}
```

```
✅ BETTER
for i := 1; i <= 100; i++ {
	if i%3 == 0 && i%5 == 0 {
		fmt.Println("i divides both 3 and 5")
		continue
	}
	if i%3 == 0 {
		fmt.Println("i divides only 3")
		continue
	}
	if i%5 == 0 {
		fmt.Println("i divides only 5")
		continue
	}

	fmt.Println("i does not divide either 3 or 5")
}
```

### for-range

- ループ関数が二つある。
- 1 つ目：

### switch

- 何らかの関係性がある状況が複数存在する場合は、if/else の連続ではなく switch を用いる方が良い場合がある。→ 比較の条件が見やすくなり、case の関係が明示できるため。

- ブランク switch と普通の switch: 比較対象の変数などを指定しない switch 文。通常の switch 文では等価かのチェックしかできないが、ブランク switch では論理的な比較が可能。しかし、全ての case が同じ変数に対する比較になっている場合は通常の switch を用いるのが良い。

## 関数

- 戻り値の無視：関数が複数の値を返してもそのうちの一つ以上を読み込む必要がないとき、使わない値は「\_」に代入できる（＝ブランク識別子）
  Go では、全ての戻り値を無視してもエラーにはならない。
- 名前つき戻り値は、戻り値を保存するための変数を使用するという「意図」を宣言するものであり、その変数を使うことを「要求」するものではない。そのため、宣言されたものを戻り値の名前に必ずしも使用しなくても良い
- 関数が値を返すなら、絶対にブランクリターンを使ってはいけない。実際に返される値が非常にわかりにくくなる

## ポインタ変数

- ポインタ：ある値が保存されているメモリ内の位置を表す

どの変数も 1 バイトもしくは何バイトか連続したメモリに保存されており、その位置のことをアドレスという。（bool は 1 バイト、int64 は 8 バイト）

`&`：アドレス演算子　その変数のアドレスを返す＝ポインタ型になる
`*`：間接参照演算子　そのポインタが参照するアドレスに保存している値を返す＝デリファレンス

- 定数をポインタに変換するには、ヘルパー関数を用いて変数を作成する

クラスのインスタンスが変数に代入されたり関数やメソッドに渡されたりするとき

- クラスのインスタンスを関数に渡し、フィールドの値を更新すると、渡された変数にその変更が反映される
- 変数に別の変数を代入するとき、渡された変数にその変更は反映されない
- 引数の値として nil/null/None を渡した場合、引数自身を新しい数に設定しても、呼び出し側の変数は変更されない

[python での値渡しの例](pointer.py)

- ポインタ型引数に代入された値が関数を終了しても残って欲しい場合は、ポインタをデリファレンスして値を設定しなければならない＝値が変更されない限り値は変わらない

## 型、メソッド、インタフェース

## エラー処理

## モジュールとパッケージ

## 並行処理

## 標準ライブラリ

## コンテキスト

## テスト

## リフレクション、unsafe, cgo

## ジェネリクス

## Go 言語のまとめ

## セットアップ

# 初めての Go

## 基本型と宣言

### 論理型

- bool のゼロ値は false

### 整数型

- 特定の大きさと特定の符号の整数バイナリのファイルあるいはネットワークプロトコルを使用しているのであれば、対応する整数型を使う
- 全ての整数型について機能しているライブラリ関数を書く場合は、引数と戻り値が int64 のものと unit64 のものの二つの関数を書かなくてはいけない。
- その他の場合は int を用いる

```
Go 1.17までジェネリクス（や関数のオーバーロード）がなかったため、全ての整数型について機能するライブラリ関数を書くときに、int64及びuint64の関数を書くのがイディオム的に正しいとされてきたが、Go1.18からジェネリクスが導入され、複数の方に対応した関数を書くことができるようになった
→符号の有無やサイズについて明示する必要がない場合はint型を用いるのが良い。理由なく他の型を用いるのは「早すぎる最適化」
```

- 0 による割り算を行うとパニックが起こる

### 変数の宣言

- 変数をゼロ値に初期化する場合は`var x int`→ ゼロ値が意図されていることが明確になる
- 型が指定されていないリテラルを変数に代入するとき、そのリテラルのデフォルトの型が希望する変数の型と異なる場合、型を指定して長い形式の`var`を用いる<br/>🤔 `x := byte(20)`→✅ `var x byte = 20`
- どの変数が新しいものであるかを明示するために、var を使って新しい変数を明示的に宣言しておいてから、「＝」を使って変数に値を代入するようにする
- `var`や`:=`は複数の変数の宣言を一行で行えるが、このスタイルを使うのは複数の値を返す関数（あるいは「カンマ ok イディオム」）からの戻り値を代入する時にだけにする

### 未使用変数

- Go には「宣言されたローカル変数は全て使われなくてはならない」というルールがある。一度も使用されてない変数があるとコンパイルエラーになる

## 合成型

### Go 配列

- Go では配列が直接使われることは多くはない
- 配列の各要素は指定された型でなくてはならない
- 最後の要素を超えるインデックスを指定したり、値が範囲外になるとコンパイルエラーになる

→ 結構制限が厳しい<br/>
→「スライス」の「後方支援」のため。

### スライス

- スライス＝「可変長の配列」。宣言時に大きさを指定しない
- スライスは比較可能でない。同じスライスかどうか判定するのに`==`や`!=`を用いるとコンパイルエラー。スライスと比較できるのは`nil`だけ。
- `...`を用いることで、スライスの個々の値を展開できる。<br/>

```
y := []int{10,20,30} //スライス。大きさを指定しない
x := append(x, y...)
```

### マップ

[map について](map.)

## ブロック、シャドーイング、制御構造

### シャドーイング

- シャドーイング変数：if 文の外側で宣言された変数名と同じ変数名を持つ、一番内側の変数（など）のこと。シャドーイング変数があると、元の変数にアクセスできなくなる。簡単に置き換えられてしまう。
- パッケージ名などもシャドーイング変数となる。ユニバースブロックにある識別子を再定義しないように気を付ける

### continue

- Go では if の本体は短くすることが求められる

```
🤔 NOT GOOD
for i := 1; i <=100; i++ {
		if i%3 == 0{
			if i%5 == 0{
				fmt.Print("i divides both 3 and 5")
			}else {
				fmt.Print("i divides only 3")
			}
		}else if i%5 == 0{
			fmt.Print("i divides only 5")
		} else {
			fmt.Print("i does not divide either 3 or 5")
		}
	}
```

```
✅ BETTER
for i := 1; i <= 100; i++ {
	if i%3 == 0 && i%5 == 0 {
		fmt.Println("i divides both 3 and 5")
		continue
	}
	if i%3 == 0 {
		fmt.Println("i divides only 3")
		continue
	}
	if i%5 == 0 {
		fmt.Println("i divides only 5")
		continue
	}

	fmt.Println("i does not divide either 3 or 5")
}
```

### for-range

- ループ関数が二つある。
- 1 つ目：

### switch

- 何らかの関係性がある状況が複数存在する場合は、if/else の連続ではなく switch を用いる方が良い場合がある。→ 比較の条件が見やすくなり、case の関係が明示できるため。

## 関数

## ポインタ変数

- ポインタ：ある値が保存されているメモリ内の位置を表す

どの変数も 1 バイトもしくは何バイトか連続したメモリに保存されており、その位置のことをアドレスという。（bool は 1 バイト、int64 は 8 バイト）

`&`：アドレス演算子　その変数のアドレスを返す＝ポインタ型になる
`*`：間接参照演算子　そのポインタが参照するアドレスに保存している値を返す＝デリファレンス

- 定数をポインタに変換するには、ヘルパー関数を用いて変数を作成する

クラスのインスタンスが変数に代入されたり関数やメソッドに渡されたりするとき

- クラスのインスタンスを関数に渡し、フィールドの値を更新すると、渡された変数にその変更が反映される
- 変数に別の変数を代入するとき、渡された変数にその変更は反映されない
- 引数の値として nil/null/None を渡した場合、引数自身を新しい数に設定しても、呼び出し側の変数は変更されない

[python での値渡しの例](pointer.py)

- ポインタ型引数に代入された値が関数を終了しても残って欲しい場合は、ポインタをデリファレンスして値を設定しなければならない＝値が変更されない限り値は変わらない

## 型、メソッド、インタフェース

## エラー処理

## モジュールとパッケージ

## 並行処理

## 標準ライブラリ

## コンテキスト

## テスト

## リフレクション、unsafe, cgo

## ジェネリクス

## Go 言語のまとめ

## セットアップ
